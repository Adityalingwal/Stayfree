import {
  app,
  Tray,
  Menu,
  nativeImage,
  BrowserWindow,
  ipcMain,
  globalShortcut,
  Notification,
  systemPreferences,
  shell,
} from "electron";
import { getHotkeyManager } from "./main/hotkey";
import { transcribe } from "./main/transcription";
import { formatText } from "./main/formatting";
import { pasteText } from "./main/paste";
import store from "./main/store";
import * as fs from "fs";
import * as path from "path";
import "dotenv/config";

// Webpack entry point declarations (auto-generated by Forge's Webpack plugin)
declare const MAIN_WINDOW_WEBPACK_ENTRY: string;
declare const MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY: string;

// Handle creating/removing shortcuts on Windows when installing/uninstalling.
if (require("electron-squirrel-startup")) {
  app.quit();
}

let tray: Tray | null = null;
let settingsWindow: BrowserWindow | null = null;
let recorderWindow: BrowserWindow | null = null;
let onboardingWindow: BrowserWindow | null = null;

// Prevent duplicate app instances (and duplicate tray icons).
const gotSingleInstanceLock = app.requestSingleInstanceLock();
if (!gotSingleInstanceLock) {
  app.quit();
}

// --- App State ---
type AppState = "idle" | "recording" | "processing";
let currentState: AppState = "idle";
let isProcessing = false; // Guard against concurrent pipeline runs

// --- Tray Icon Creation (using PNG files for reliability) ---

// Get the path to icon files
function getIconPath(): string {
  const iconName = "trayTemplate.png";
  // Assets are copied to 'assets' folder in webpack output
  return path.join(__dirname, "assets", iconName);
}

function createTrayIcon(): Electron.NativeImage {
  const iconPath = getIconPath();
  const image = nativeImage.createFromPath(iconPath);

  if (image.isEmpty()) {
    console.error(`[StayFree] ERROR: Icon not found at: ${iconPath}`);
  }

  // Mark as template so macOS can adapt icon color to menu bar style.
  image.setTemplateImage(true);

  return image;
}

function updateTrayState(state: AppState): void {
  currentState = state;
  if (tray) {
    tray.setImage(createTrayIcon());
    tray.setToolTip(
      state === "idle"
        ? "StayFree - Ready (Hold Fn to dictate)"
        : state === "recording"
          ? "StayFree - Recording..."
          : "StayFree - Processing...",
    );
  }
}

// Export for use by other modules later
export { updateTrayState, currentState };
export type { AppState };

// --- Context Menu ---

function buildContextMenu(): Menu {
  return Menu.buildFromTemplate([
    {
      label: `StayFree v${app.getVersion()}`,
      enabled: false,
    },
    { type: "separator" },
    {
      label: "Paste Last Transcript",
      accelerator: "Ctrl+Cmd+V",
      click: async () => {
        const lastTranscript = store.get("lastTranscript") as string;
        if (lastTranscript) {
          await pasteText(lastTranscript);
        }
      },
    },
    { type: "separator" },
    {
      label: "Settings...",
      accelerator: "Cmd+,",
      click: () => {
        openSettingsWindow();
      },
    },
    { type: "separator" },
    {
      label: "Quit StayFree",
      accelerator: "Cmd+Q",
      click: () => {
        app.quit();
      },
    },
  ]);
}

// --- Recorder Window (Hidden) ---

function createRecorderWindow(): void {
  recorderWindow = new BrowserWindow({
    width: 400,
    height: 300,
    show: false, // Hidden window
    webPreferences: {
      preload: MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY,
      nodeIntegration: false,
      contextIsolation: true,
    },
  });

  recorderWindow.loadURL(MAIN_WINDOW_WEBPACK_ENTRY);

  recorderWindow.on("closed", () => {
    recorderWindow = null;
  });

  console.log("[StayFree] Hidden recorder window created");
}

// --- Settings / Dashboard Window ---

function openSettingsWindow(): void {
  if (settingsWindow) {
    settingsWindow.focus();
    return;
  }

  // Show dock so the dashboard window is discoverable
  if (process.platform === "darwin") {
    app.dock.show();
  }

  settingsWindow = new BrowserWindow({
    width: 1200,
    height: 800,
    title: "StayFree",
    minWidth: 800,
    minHeight: 600,
    show: false,
    titleBarStyle: "hiddenInset",
    trafficLightPosition: { x: 16, y: 16 },
    webPreferences: {
      preload: MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY,
      nodeIntegration: false,
      contextIsolation: true,
    },
  });

  settingsWindow.loadURL(`${MAIN_WINDOW_WEBPACK_ENTRY}#settings`);

  settingsWindow.once("ready-to-show", () => {
    settingsWindow.show();
  });

  settingsWindow.on("closed", () => {
    settingsWindow = null;
    if (process.platform === "darwin") {
      app.dock.hide();
    }
  });
}

// --- Onboarding Window ---

function needsOnboarding(): boolean {
  if (store.get("onboardingComplete")) {
    // Even if onboarding was completed, re-show if permissions were revoked
    const micStatus = systemPreferences.getMediaAccessStatus("microphone");
    const accessibilityGranted =
      systemPreferences.isTrustedAccessibilityClient(false);
    if (micStatus === "granted" && accessibilityGranted) {
      return false;
    }
    console.log(
      "[Onboarding] Permissions revoked since last onboarding - re-showing",
    );
  }
  return true;
}

function showOnboardingWindow(): void {
  if (onboardingWindow) {
    onboardingWindow.focus();
    return;
  }

  // Temporarily show dock so the onboarding window is discoverable
  if (process.platform === "darwin") {
    app.dock.show();
  }

  onboardingWindow = new BrowserWindow({
    width: 520,
    height: 600,
    title: "Welcome to StayFree",
    resizable: false,
    minimizable: false,
    maximizable: false,
    fullscreenable: false,
    show: false,
    webPreferences: {
      preload: MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY,
      nodeIntegration: false,
      contextIsolation: true,
    },
  });

  // Hash routing: renderer.ts checks window.location.hash to decide what to render
  onboardingWindow.loadURL(`${MAIN_WINDOW_WEBPACK_ENTRY}#onboarding`);

  onboardingWindow.once("ready-to-show", () => {
    onboardingWindow.show();
  });

  onboardingWindow.on("closed", () => {
    onboardingWindow = null;
    // Hide dock again after onboarding closes
    if (process.platform === "darwin") {
      app.dock.hide();
    }
  });

  console.log("[Onboarding] Window created");
}

// --- Permission IPC Handlers ---

function registerPermissionHandlers(): void {
  ipcMain.handle("check-permissions", () => {
    const mic = systemPreferences.getMediaAccessStatus("microphone");
    const accessibility = systemPreferences.isTrustedAccessibilityClient(false);
    return { mic, accessibility };
  });

  ipcMain.handle("request-mic-permission", async () => {
    const granted = await systemPreferences.askForMediaAccess("microphone");
    return granted;
  });

  ipcMain.on("open-accessibility-settings", () => {
    // Prompt the system dialog
    systemPreferences.isTrustedAccessibilityClient(true);
    shell.openExternal(
      "x-apple.systempreferences:com.apple.preference.security?Privacy_Accessibility",
    );
  });

  ipcMain.on("open-keyboard-settings", () => {
    shell.openExternal(
      "x-apple.systempreferences:com.apple.preference.keyboard",
    );
  });

  ipcMain.on("complete-onboarding", () => {
    store.set("onboardingComplete", true);
    console.log("[Onboarding] Completed");
    if (onboardingWindow) {
      onboardingWindow.close();
    }
  });
}

// --- Settings IPC Handlers ---

function registerSettingsHandlers(): void {
  ipcMain.handle("get-settings", () => {
    return {
      groqApiKey: store.get("groqApiKey"),
      selectedMicId: store.get("selectedMicId"),
      soundEnabled: store.get("soundEnabled"),
      dictionary: store.get("dictionary"),
    };
  });

  ipcMain.handle("save-api-key", (_event, key: string) => {
    store.set("groqApiKey", key);
    console.log("[Settings] API key saved");
  });

  ipcMain.on("save-selected-mic", (_event, deviceId: string) => {
    store.set("selectedMicId", deviceId);
    console.log(`[Settings] Microphone saved: ${deviceId || "system default"}`);
  });

  ipcMain.on("save-sound-enabled", (_event, enabled: boolean) => {
    store.set("soundEnabled", enabled);
    console.log(`[Settings] Sound ${enabled ? "enabled" : "disabled"}`);
  });

  ipcMain.handle("get-dictionary", () => {
    return store.get("dictionary");
  });

  ipcMain.on(
    "save-dictionary",
    (_event, dictionary: Record<string, string>) => {
      store.set("dictionary", dictionary);
      console.log(
        `[Settings] Dictionary saved (${Object.keys(dictionary).length} entries)`,
      );
    },
  );

  ipcMain.handle("get-transcription-history", () => {
    return store.get("transcriptionHistory");
  });

  ipcMain.on("clear-transcription-history", () => {
    store.set("transcriptionHistory", []);
    console.log("[Settings] History cleared");
  });

  ipcMain.handle("get-app-version", () => {
    return app.getVersion();
  });
}

// --- App Lifecycle ---

app.on("ready", () => {
  // Hide dock icon on macOS - this is a tray-only app
  if (process.platform === "darwin") {
    app.dock.hide();
  }

  // Register IPC handlers (needed before any window loads)
  registerPermissionHandlers();
  registerSettingsHandlers();

  // Create system tray
  tray = new Tray(createTrayIcon());
  tray.setContextMenu(buildContextMenu());
  tray.setToolTip("StayFree - Ready (Hold Fn to dictate)");

  console.log(
    "[StayFree] Running in system tray. Right-click tray icon for menu.",
  );

  // Create hidden recorder window (for Web Audio API access)
  createRecorderWindow();

  // Show onboarding if first launch or permissions missing
  if (needsOnboarding()) {
    showOnboardingWindow();
  }

  // Initialize hotkey manager (Fn key for push-to-talk)
  const hotkeyManager = getHotkeyManager({ useFnKey: true });

  hotkeyManager.on("recording-start", () => {
    console.log("[Main] Hotkey pressed - starting recording");
    updateTrayState("recording");

    // Tell recorder window to start capturing audio
    if (recorderWindow) {
      recorderWindow.webContents.send("start-recording");
    }
  });

  hotkeyManager.on("recording-stop", () => {
    console.log("[Main] Hotkey released - stopping recording");
    // Go directly to "processing" - avoids idle flash between recording and processing
    updateTrayState("processing");

    // Tell recorder window to stop and send audio
    if (recorderWindow) {
      recorderWindow.webContents.send("stop-recording");
    }
  });

  // Start listening for hotkeys
  hotkeyManager.start();

  // Register fallback hotkey: Ctrl+Cmd+V pastes last transcript
  globalShortcut.register("Ctrl+Cmd+V", async () => {
    const lastTranscript = store.get("lastTranscript") as string;
    if (lastTranscript) {
      console.log("[Main] Fallback hotkey: pasting last transcript");
      const pasted = await pasteText(lastTranscript);
      if (!pasted) {
        console.error("[Main] Fallback paste failed");
      }
    } else {
      console.log("[Main] Fallback hotkey: no last transcript to paste");
    }
  });

  // IPC Handler: Receive audio blob from renderer — full pipeline
  ipcMain.on("audio-captured", async (_event, audioData: Buffer) => {
    // Guard: prevent concurrent pipeline runs
    if (isProcessing) {
      console.warn("[Pipeline] Already processing - ignoring new audio");
      return;
    }
    isProcessing = true;

    const pipelineStart = Date.now();
    console.log(`\n[Pipeline] ═══ START ═══ (${audioData.length} bytes)`);

    // Tray should already be "processing" from recording-stop handler
    updateTrayState("processing");

    try {
      // --- Save audio for debugging ---
      const recordingsDir = path.join(__dirname, "..", "..", "recordings");
      if (!fs.existsSync(recordingsDir)) {
        fs.mkdirSync(recordingsDir, { recursive: true });
      }
      const timestamp = new Date().toISOString().replace(/[:.]/g, "-");
      const audioPath = path.join(recordingsDir, `recording-${timestamp}.webm`);
      fs.writeFileSync(audioPath, audioData);
      console.log(`[Pipeline] Audio saved: ${audioPath}`);

      // --- Step 1: ASR (Speech-to-Text) ---
      const asrStart = Date.now();
      const transcript = await transcribe(audioData);
      const L_asr = Date.now() - asrStart;

      if (!transcript) {
        console.error(`[Pipeline] ✗ ASR failed (${L_asr}ms)`);
        new Notification({
          title: "StayFree",
          body: "Transcription failed. Please try again.",
          silent: true,
        }).show();
        return; // finally block will reset tray + isProcessing
      }

      console.log(`[Pipeline] ✓ ASR (${L_asr}ms): "${transcript}"`);

      // --- Step 2: LLM Formatting ---
      const llmStart = Date.now();
      const formattedText = await formatText(transcript);
      const L_llm = Date.now() - llmStart;

      console.log(`[Pipeline] ✓ LLM (${L_llm}ms): "${formattedText}"`);

      // Store for fallback paste (Ctrl+Cmd+V)
      store.set("lastTranscript", formattedText);

      // Save to transcription history (keep last 100)
      const history = store.get("transcriptionHistory") as Array<{
        text: string;
        rawText: string;
        timestamp: number;
        durationMs: number;
      }>;
      history.unshift({
        text: formattedText,
        rawText: transcript,
        timestamp: Date.now(),
        durationMs: Date.now() - pipelineStart,
      });
      if (history.length > 100) history.length = 100;
      store.set("transcriptionHistory", history);

      // --- Step 3: Paste ---
      const pasteStart = Date.now();
      const pasted = await pasteText(formattedText);
      const L_paste = Date.now() - pasteStart;

      if (pasted) {
        console.log(`[Pipeline] ✓ Paste (${L_paste}ms)`);
      } else {
        console.error(
          `[Pipeline] ✗ Paste failed (${L_paste}ms) - text in clipboard for manual Cmd+V`,
        );
      }

      // --- Timing Summary ---
      const L_total = Date.now() - pipelineStart;
      console.log(
        `[Pipeline] ═══ DONE ═══ L_asr=${L_asr}ms | L_llm=${L_llm}ms | L_paste=${L_paste}ms | L_total=${L_total}ms`,
      );
    } catch (error) {
      const L_total = Date.now() - pipelineStart;
      console.error(`[Pipeline] ✗ FATAL ERROR after ${L_total}ms:`, error);

      new Notification({
        title: "StayFree",
        body: "Something went wrong. Please try again.",
        silent: true,
      }).show();
    } finally {
      // Always reset state — no matter what happened
      isProcessing = false;
      updateTrayState("idle");
    }
  });
});

// Tray app: keep running when all windows closed
app.on("window-all-closed", () => {
  // Do nothing - app lives in tray, not in windows
});

app.on("before-quit", () => {
  // Unregister global shortcuts
  globalShortcut.unregisterAll();

  // Stop hotkey listener
  const hotkeyManager = getHotkeyManager();
  hotkeyManager.stop();

  if (tray) {
    tray.destroy();
    tray = null;
  }
});
